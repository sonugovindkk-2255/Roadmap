
import 'dart:math' as math;
import 'package:flutter/material.dart';

void main() => runApp(const GameMapApp());

class GameMapApp extends StatelessWidget {
  const GameMapApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Game Route Map',
      theme: ThemeData(useMaterial3: true, colorSchemeSeed: Colors.teal),
      home: const GameMapPage(),
      debugShowCheckedModeBanner: false,
    );
  }
}

class GameMapPage extends StatefulWidget {
  const GameMapPage({super.key});

  @override
  State<GameMapPage> createState() => _GameMapPageState();
}

class _GameMapPageState extends State<GameMapPage> {
  // Define your path by control points (cubic Bézier segments).
  // This gives a smooth “sigmoid / snake-like” route.
  final List<CubicSegment> segments = [
    // x,y in a virtual canvas (will be scaled to screen)
    CubicSegment(
      const Offset(80, 120),
      const Offset(260, 60),
      const Offset(260, 220),
      const Offset(80, 200),
    ),
    CubicSegment(
      const Offset(80, 200),
      const Offset(-60, 220),
      const Offset(-60, 380),
      const Offset(110, 400),
    ),
    CubicSegment(
      const Offset(110, 400),
      const Offset(330, 420),
      const Offset(330, 570),
      const Offset(110, 590),
    ),
    CubicSegment(
      const Offset(110, 590),
      const Offset(-60, 610),
      const Offset(-60, 780),
      const Offset(150, 800),
    ),
  ];

  // Milestones placed at normalized distances (0..1) along the whole path.
  // Example: 0.08 = 8% of full length.
  final List<double> milestoneTs = [0.08, 0.26, 0.47, 0.63, 0.82];

  // Current progress index (for highlight)
  final int currentIndex = 1; // 0-based among milestoneTs

  @override
  Widget build(BuildContext context) {
    // Virtual canvas size in which segments were defined
    const Size worldSize = Size(360, 1000);

    return Scaffold(
      backgroundColor: const Color(0xFFF6F9E9), // soft greenish background
      appBar: AppBar(
        title: const Text('Adventure Map'),
        centerTitle: true,
      ),
      body: LayoutBuilder(
        builder: (context, viewport) {
          // scale world to fit width; keep vertical scroll
          final scale = viewport.maxWidth / worldSize.width;
          final canvasSize = Size(viewport.maxWidth, worldSize.height * scale);

          return SingleChildScrollView(
            physics: const BouncingScrollPhysics(),
            child: SizedBox(
              width: canvasSize.width,
              height: canvasSize.height,
              child: Stack(
                children: [
                  // 1) Background scenery
                  CustomPaint(
                    size: canvasSize,
                    painter: WorldBackgroundPainter(worldSize: worldSize, scale: scale),
                  ),
                  // 2) Route band (below avatars)
                  CustomPaint(
                    size: canvasSize,
                    painter: RoutePainter(
                      segments: segments,
                      worldSize: worldSize,
                      scale: scale,
                      bandColor: const Color(0xFF6EC3A2),
                      bandShadowColor: const Color(0x336EC3A2),
                      bandWidth: 36,
                      strokeWidth: 8,
                      progressT: milestoneTs[(currentIndex).clamp(0, milestoneTs.length - 1)],
                      progressColor: const Color(0xFF28A57A),
                      restColor: const Color(0xFFEED8B9),
                    ),
                  ),
                  // 3) Milestone avatars (placed ON the path)
                  ...List.generate(milestoneTs.length, (i) {
                    return MilestoneOnPath(
                      t: milestoneTs[i],
                      segments: segments,
                      worldSize: worldSize,
                      scale: scale,
                      isCurrent: i == currentIndex,
                      // Replace with your asset when ready
                      child: MilestoneAvatar(
                        color: i < currentIndex
                            ? const Color(0xFF28A57A)
                            : (i == currentIndex ? Colors.orange : const Color(0xFF8AA59B)),
                        label: 'Lv ${i + 1}',
                      ),
                    );
                  }),
                  // 4) Optional: static decorative stickers (tree, lake shapes)
                  ..._stickers(canvasSize),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  List<Widget> _stickers(Size canvasSize) {
    // Quick decorative blobs (you can swap for images)
    return [
      Positioned(
        right: 12,
        top: 140,
        child: _blob(width: 48, height: 90, color: const Color(0xFF6DAE63), radius: 18),
      ),
      Positioned(
        left: 16,
        top: 500,
        child: _blob(width: 70, height: 42, color: const Color(0xFF89B27C), radius: 14),
      ),
      Positioned(
        right: 20,
        bottom: 160,
        child: _blob(width: 120, height: 80, color: const Color(0xFFC7E7FF), radius: 30, border: const Color(0xFF79AACA)),
      ),
    ];
  }

  Widget _blob({
    required double width,
    required double height,
    required Color color,
    Color? border,
    double radius = 20,
  }) {
    return Container(
      width: width,
      height: height,
      decoration: BoxDecoration(
        color: color,
        borderRadius: BorderRadius.circular(radius),
        border: border != null ? Border.all(color: border, width: 3) : null,
      ),
    );
  }
}

/* -------------------- DATA TYPES ---------------------- */

class CubicSegment {
  final Offset p0, p1, p2, p3;
  const CubicSegment(this.p0, this.p1, this.p2, this.p3);
}

/* -------------------- BACKGROUND ---------------------- */

class WorldBackgroundPainter extends CustomPainter {
  WorldBackgroundPainter({required this.worldSize, required this.scale});

  final Size worldSize;
  final double scale;

  @override
  void paint(Canvas canvas, Size size) {
    // Gentle noise-ish rectangles & shapes for a playful landscape
    final bg = Paint()..color = const Color(0xFFF6F9E9);
    canvas.drawRect(Offset.zero & size, bg);

    // Big rounded shapes
    final shapes = [
      _roundedBlob(Rect.fromLTWH(0 * scale, 90 * scale, 180 * scale, 70 * scale), const Color(0xFFDAE9C8)),
      _roundedBlob(Rect.fromLTWH(200 * scale, 300 * scale, 140 * scale, 100 * scale), const Color(0xFFDAE9C8)),
      _roundedBlob(Rect.fromLTWH(20 * scale, 720 * scale, 140 * scale, 120 * scale), const Color(0xFFEDEAD2)),
    ];
    for (final s in shapes) {
      canvas.drawPath(s, Paint()..color = s.getBounds().height > 0 ? (s.getBounds().height > 0 ? (s.fillType == PathFillType.nonZero ? const Color(0xFFDAE9C8) : const Color(0xFFEDEAD2)) : const Color(0xFFDAE9C8)) : const Color(0xFFDAE9C8));
    }
  }

  Path _roundedBlob(Rect r, Color c) {
    final path = Path()
      ..addRRect(RRect.fromRectAndRadius(r, Radius.circular(r.shortestSide * 0.35)));
    path.fillType = PathFillType.nonZero;
    return path;
  }

  @override
  bool shouldRepaint(covariant WorldBackgroundPainter oldDelegate) => false;
}

/* -------------------- ROUTE PAINTER ---------------------- */

class RoutePainter extends CustomPainter {
  RoutePainter({
    required this.segments,
    required this.worldSize,
    required this.scale,
    required this.bandColor,
    required this.bandShadowColor,
    required this.bandWidth,
    required this.strokeWidth,
    required this.progressT,
    required this.progressColor,
    required this.restColor,
  });

  final List<CubicSegment> segments;
  final Size worldSize;
  final double scale;

  final Color bandColor;
  final Color bandShadowColor;
  final double bandWidth;
  final double strokeWidth;

  /// Normalized progress (0..1) to tint the route up to current node.
  final double progressT;
  final Color progressColor;
  final Color restColor;

  @override
  void paint(Canvas canvas, Size size) {
    // Build full path in world space; then scale to screen.
    final worldPath = Path();
    for (final s in segments) {
      if (worldPath.isEmpty) {
        worldPath.moveTo(s.p0.dx, s.p0.dy);
      }
      worldPath.cubicTo(s.p1.dx, s.p1.dy, s.p2.dx, s.p2.dy, s.p3.dx, s.p3.dy);
    }

    final mat = Matrix4.identity()
      ..scale(scale, scale)
      ..translate(0.0, 0.0);
    final path = worldPath.transform(mat.storage);

    // Draw a thick “band” underlay (restColor) + a “filled progress” on top
    final bandPaint = Paint()
      ..color = restColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = bandWidth
      ..strokeCap = StrokeCap.round;

    final bandPaintProgress = Paint()
      ..color = bandColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = bandWidth
      ..strokeCap = StrokeCap.round;

    // subtle edge stroke
    final edgePaint = Paint()
      ..color = bandShadowColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = strokeWidth
      ..strokeCap = StrokeCap.round;

    // whole band (rest color)
    canvas.drawPath(path, bandPaint);
    // outer edge
    canvas.drawPath(path, edgePaint);

    // progress subpath (t 0..1)
    final pm = path.computeMetrics().first;
    final len = pm.length * progressT.clamp(0.0, 1.0);
    final activePath = pm.extractPath(0, len);
    canvas.drawPath(activePath, bandPaintProgress);
  }

  @override
  bool shouldRepaint(covariant RoutePainter oldDelegate) {
    return oldDelegate.progressT != progressT ||
        oldDelegate.bandColor != bandColor ||
        oldDelegate.restColor != restColor ||
        oldDelegate.bandWidth != bandWidth ||
        oldDelegate.segments != segments ||
        oldDelegate.scale != scale;
  }
}

/* -------------------- MILESTONES ON PATH ---------------------- */

class MilestoneOnPath extends StatelessWidget {
  const MilestoneOnPath({
    super.key,
    required this.t,
    required this.segments,
    required this.worldSize,
    required this.scale,
    required this.isCurrent,
    required this.child,
  });

  final double t;
  final List<CubicSegment> segments;
  final Size worldSize;
  final double scale;
  final bool isCurrent;
  final Widget child;

  @override
  Widget build(BuildContext context) {
    // Build world path
    final worldPath = Path();
    for (final s in segments) {
      if (worldPath.isEmpty) worldPath.moveTo(s.p0.dx, s.p0.dy);
      worldPath.cubicTo(s.p1.dx, s.p1.dy, s.p2.dx, s.p2.dy, s.p3.dx, s.p3.dy);
    }
    final mat = Matrix4.identity()..scale(scale, scale);
    final path = worldPath.transform(mat.storage);
    final pm = path.computeMetrics().first;
    final pos = pm.getTangentForOffset(pm.length * t.clamp(0.0, 1.0))!;
    final point = pos.position;

    return Positioned(
      left: point.dx - 28,
      top: point.dy - 28,
      child: AnimatedScale(
        duration: const Duration(milliseconds: 250),
        scale: isCurrent ? 1.1 : 1.0,
        child: child,
      ),
    );
  }
}

/* -------------------- AVATAR WIDGET ---------------------- */

class MilestoneAvatar extends StatelessWidget {
  const MilestoneAvatar({
    super.key,
    required this.color,
    required this.label,
    this.size = 56,
    this.imageProvider,
  });

  final Color color;
  final String label;
  final double size;
  final ImageProvider? imageProvider;

  @override
  Widget build(BuildContext context) {
    final borderColor = Colors.white;
    return Container(
      width: size,
      height: size,
      decoration: BoxDecoration(
        color: imageProvider == null ? color : null,
        image: imageProvider != null ? DecorationImage(image: imageProvider!, fit: BoxFit.cover) : null,
        shape: BoxShape.circle,
        border: Border.all(color: borderColor, width: 3),
        boxShadow: const [BoxShadow(color: Colors.black26, blurRadius: 6, offset: Offset(0, 2))],
      ),
      alignment: Alignment.center,
      child: imageProvider == null
          ? Text(label, style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold))
          : null,
    );
  }
}

List<CubicSegment> generateSnakePath({
  required double screenWidth,
  required double segmentHeight,
  int segments = 4,  // number of U shapes
}) {
  final List<CubicSegment> path = [];
  double y = 0;
  bool goRight = true;

  for (int i = 0; i < segments; i++) {
    if (goRight) {
      // Go LEFT → RIGHT then curve down
      path.add(
        CubicSegment(
          Offset(0, y),                        // start
          Offset(screenWidth * 0.33, y),       // straight line control 1
          Offset(screenWidth * 0.66, y + segmentHeight), // curve control 2
          Offset(screenWidth, y + segmentHeight),         // end at right
        ),
      );
    } else {
      // Go RIGHT → LEFT then curve down
      path.add(
        CubicSegment(
          Offset(screenWidth, y),              // start
          Offset(screenWidth * 0.66, y),       // straight line control 1
          Offset(screenWidth * 0.33, y + segmentHeight), // curve control 2
          Offset(0, y + segmentHeight),        // end at left
        ),
      );
    }

    y += segmentHeight;
    goRight = !goRight; // alternate directions
  }

  return path;
}
